const fs = require('fs');
const TilesJSPObject = require('../objects/tiles-jsp-object');
const Util = require('../utility/util');
const logger = require('../utility/logger')(
  {
    id: 'tiles.js'
  },
  'verbose'
);
/**
 * Fetches all of the JSPs included in the static list of
 * tiles-def.xml files (Util.TILES). Creates "tiles JSP Objects"
 * to inform the client about attributes of each JSP (which tiles-def
 * derived, is top level or nested, etc.). Writes tiles.json to the
 * processor-output directory.
 */
class Tiles {
  /**
   * Creates an instance of Tiles.
   */
  constructor() {
    /**
     * Array of root definition names pulled from the tiles-def
     * @type {string[]}
     */
    this.rootDefinitionNames = [];
    /**
     * Array of deep tile JSP objects. These are tile-jsp-objects and
     * deep-object
     * @type {Object[]}
     */
    this.deepTilesJSPObjects = [];
  }

  /**
   * The entry point for this class.
   *
   * @param {Boolean} hasReport If the hasReport flag is passed, we write
   *  any warnings generated by this processor to report.json. Driven
   *  by the CLI flag --report.
   * @return {Promise} Resolves the unique tiles JSP objects
   *  and tiles root definition names
   * @memberof Tiles
   */
  execute(hasReport) {
    return this.getTopLevelTilesJSPObjects()
      .then(this.getDeepTilesJSPObjects.bind(this))
      .then(data => {
        return hasReport
          ? Util.appendWarningsToReport(
              data.warningObjs,
              'tiles',
              this.deepTilesJSPObjects
            )
          : this.deepTilesJSPObjects;
      })
      .then(this.getTilesJSPObjectsFromDeepJSPObject.bind(this))
      .then(this.writeTilesJSPObjectsToDisk.bind(this));
  }

  /**
   * A stand-alone function to return the tiles definition names from
   * the set of tiles def XMLs.
   *
   * @static
   * @return {Promise} Resolves an array of tiles definition names.
   * @memberof Tiles
   */
  static getDefinitionNames() {
    return Util.getTilesFiles().then(tiles => {
      return Promise.all(
        tiles.map(tile => {
          return Util.readFilePromise(tile).then(data => {
            const rootDefintionNames = [];
            const tileDefinitions = Util.getTileDefinitions(
              data.fileData,
              tile
            );
            tileDefinitions.forEach((definitionBlock, i) => {
              const definitionTag = definitionBlock.match(
                Util.getTagRegex('definition')
              );
              // First, pull the root definition name from the
              // definition tag.
              let name =
                (definitionTag[0] || '').match(Util.getPropertyValue('name')) ||
                [];
              // Transform this array to a cleaned string representing the
              // name of the tiles-def definition.
              name = Util.getCleanedStr(name.length > 0 ? name[0] : '');
              // Return the definition name
              rootDefintionNames.push(name);
            });
            return rootDefintionNames;
          });
        })
      ).then(names => {
        // Merge all tiles definition names
        return names.reduce((acc, arr) => acc.concat(arr), []);
      });
    });
  }

  /**
   * Returns an array of tiles JSP Objects derived from tiles-def.xmls
   * (Util.TILES). These represent the top level files that need to be deep
   * nested to get all of the child JSP references.
   *
   * @return {Promise}
   * @memberof Tiles
   */
  getTopLevelTilesJSPObjects() {
    logger.info(
      'getTopLevelTilesJSPObjects:',
      'Aggregating array of Tiles JSP Objects'
    );
    return Util.getTilesFiles().then(tiles => {
      return Promise.all(
        tiles.map(tile => {
          return Util.readFilePromise(tile)
            .then(data => {
              // let jsps = Util.getJSPsInTile(data.fileData);
              const tilesJSPObjects = [];
              const tileDefinitions = Util.getTileDefinitions(
                data.fileData,
                tile
              );
              tileDefinitions.forEach((definitionBlock, i) => {
                const definitionTag = definitionBlock.match(
                  Util.getTagRegex('definition')
                );
                // First, pull the root definition name from the definition tag.
                let name =
                  (definitionTag[0] || '').match(
                    Util.getPropertyValue('name')
                  ) || [];
                // Transform this array to a cleaned string representing the
                // name of the tiles-def definition.
                name = Util.getCleanedStr(name.length > 0 ? name[0] : '');
                // Push this root definition name to an array to be
                // referenced later.
                this.rootDefinitionNames.push(name);
                // Next, pull the extends attriute value from the definition tag
                let extend =
                  (definitionTag[0] || '').match(
                    Util.getPropertyValue('extends')
                  ) || [];
                // Transform this array to a cleaned string representing what
                // this tiles-def definition extends (parent).
                extend = Util.getCleanedStr(extend.length > 0 ? extend[0] : '');
                // Next, extract all jsps from the tiles-def definition
                const jsps = Util.getJSPsFromDefinition(definitionBlock);
                // Finally, build the tilesJSPObjects using all of the info
                // from the previous steps.
                jsps.forEach(jsp => {
                  tilesJSPObjects.push(
                    new TilesJSPObject({
                      tilesXML: tile,
                      path: jsp,
                      rootExtendsDefinition: extend,
                      rootDefinitionName: name
                    })
                  );
                });
              });
              return tilesJSPObjects;
            })
            .catch(error => {
              logger.error('getTopLevelTilesJSPObjects', error);
            });
        })
      ).then(tilesJSPObjectArrays => {
        logger.info(
          'getTopLevelTilesJSPObjects:',
          'Completed. Returning array of Tiles JSP Objects.'
        );
        // Merge all of the tiles JSP objects to one array.
        const mergedTilesJSPObjects = tilesJSPObjectArrays.reduce(
          (acc, arr) => acc.concat(arr),
          []
        );
        // Get unique tiles JSP objects by "tilesXML" and "path" prop vals.
        // This defines uniqueness using the value of the tilesXML and path
        // property values.
        return Util.uniqueObjArray(mergedTilesJSPObjects, 'tilesXML', 'path');
      });
    });
  }

  /**
   * Returns an array of deep "Tiles" JSPObjects derived from the JSP path
   * strings. The tilesJSPObjectArray is the result of fetching all of the
   * JSP inclusions within all of the tiles-def XMLs
   * (getTopLevelTilesJSPObjects). Each tiles JSP object has a "path" which
   * maps to the deep JSP object.
   *
   * @param {Array} tilesJSPObjectArray The array of tiles jsp objects.
   * @return {Promise} Resolves the deep Tiles JSPObjects derived from
   *  tilesJSPObjectArray. Merges the tiles-jsp-object and jsp-obect.
   * @memberof Tiles
   */
  getDeepTilesJSPObjects(tilesJSPObjectArray) {
    logger.info(
      'getDeepTilesJSPObjects: Aggregating array of deep tiles JSPObjects'
    );
    return new Promise((resolve, reject) => {
      Util.readStream({
        file: Util.processorOutput('deep.json'),
        onData: data => {
          const deepJSPObject = data.value;
          const indexOfPath = tilesJSPObjectArray.findIndex(tilesJSPObject => {
            return tilesJSPObject.path === deepJSPObject.path;
          });
          if (indexOfPath > -1) {
            // At this point we want to merge the properties specific to "tiles"
            // object into the deep JSP Object. Creating a monster object
            // of great meta value. deep jsp object <-- tiles jsp object
            const deepTilesJSPObject = Object.assign(
              deepJSPObject,
              tilesJSPObjectArray[indexOfPath]
            );
            this.deepTilesJSPObjects.push(deepTilesJSPObject);
          }
        },
        onEnd: () => {
          const deepPaths = this.deepTilesJSPObjects.map(deepJSP => {
            return deepJSP.path;
          });
          const tilesJSPPaths = tilesJSPObjectArray.map(
            tilesJSPObject => tilesJSPObject.path
          );
          const missing = tilesJSPPaths.filter(x => !deepPaths.includes(x));
          let objs = [];
          if (missing.length > 0) {
            // Reverse lookup object(s).
            objs = tilesJSPObjectArray.filter(obj => {
              return missing.includes(obj.path);
            });
            const _method = 'getDeepTilesJSPObjects:';
            const _missing = JSON.stringify(missing, null, 2);
            const _message = `Couldn't get deep JSPObject for ${_missing}.\n`;
            const _info1 = 'Possibly an orphaned file or deprecated reference.';
            const _info2 = 'Did you pull from develop and not re-run index.js?';
            logger.warn(`${_method} ${_message} ${_info1} ${_info2}`, objs);
          }
          logger.info(
            'getDeepTilesJSPObjects:',
            'Completed. Returing array of deep tiles JSPObjects'
          );
          resolve({
            deepTilesJSPObjects: this.deepTilesJSPObjects,
            warningObjs: objs
          });
        },
        onError: error => {
          reject(error);
        }
      });
    });
  }

  /**
   * Returns the unique tiles jsp objects derived from the deepTilesJSPObjects.
   *
   * @param {Array} deepTilesJSPObjects The deep tilesJSPObjects to
   *  pull JSP paths from.
   * @return {Array}
   * @memberof Tiles
   */
  getTilesJSPObjectsFromDeepJSPObject(deepTilesJSPObjects) {
    const tilesJSPObjects = Util.getTilesJSPObjectsFromDeepTilesJSPObjectArray(
      deepTilesJSPObjects
    );
    // TODO: Do we really want this?
    // Give me the occurences of objects whose 'path' values are unique.
    const uniqueTilesJSPObjects = Util.uniqueObjArray(tilesJSPObjects, 'path');
    return uniqueTilesJSPObjects;
  }

  /**
   * Writes the {@link uniqueTilesJSPObjects} to the procoessor-output
   * directory as tiles.json.
   *
   * @param {Object[]} uniqueTilesJSPObjects The tiles JSP Objects to write
   *  to disk.
   * @return {Promise} Resolves {
   *  tileJSPObjects: {@link uniqueTilesJSPObjects},
   *  rootDefinitionNames: {@link rootDefinitionNames}
   * }
   * @memberof Tiles
   */
  writeTilesJSPObjectsToDisk(uniqueTilesJSPObjects) {
    return new Promise((resolve, reject) => {
      fs.writeFile(
        Util.processorOutput('tiles.json'),
        JSON.stringify(uniqueTilesJSPObjects, null, 1),
        'utf8',
        err => {
          if (err) {
            reject(err);
          }
          logger.info(
            'writeTilesJSPObjectsToDisk:',
            'Wrote tiles.json to disk'
          );
          resolve({
            tileJSPObjects: uniqueTilesJSPObjects,
            rootDefinitionNames: this.rootDefinitionNames
          });
        }
      );
    });
  }
}
module.exports = Tiles;
